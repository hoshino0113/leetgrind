December 4, 2025
Note to all leetcode questions have done


+++++++++++++++++++++++++++++++++++++++++

two_sum:

In order to do this question, we used list, hashmap and iteration in the solution
List has the syntax of
- solution[1, 2, 3, 4]
- solution.index(2) will return the index of 2 in the solution

Hashmap has the syntax of
- store_value = {
    key : value
}
- Both key and value can be int, bool, string
To add a value to a hashmap
- store_value[1] = 2
To check if key '1' is in the map:
- if 1 in store_value -> return true if exists

We have also noticed that to make our iterator more efficient/conventional, we should use enum instead of i = 0 at the begining:
for i, num in enumerate(nums):
            complement = target - num
            if complement in store_value:
                return [store_value[complement], i]

1 takeaway:
When we know the brute force to solve this issue, to optimize the solution, we can think in these two directions:
- How can we make one specific part of the algorithm faster? (In this case, how can we make the search faster)
- Consider 'Space wise' solution: How can we sacrifice a bit space to make the algorithm faster?

+++++++++++++++++++++++++++++++++++++++++

buy_stock:

Keep the min price, and a record of max_profit so far.
Then find the max of current price - min price and the max_profit
update min price when the new price is lower than that price.
Initial thought was correct:
"          If we found a elemnet that is smaller than the element we are currrently checking (lets call it c), we record
#           the current highest profit and immediately change our left pointer to that element."
Because it means that if we have any higher price later on, the c must be less profitable. But, in case of this:
[6, 20, 4, 7], we keep the max_profit which is 14 (20 - 6) and move on from 4.

+++++++++++++++++++++++++++++++++++++++++

contain_duplicates

Use hashmap to solve it faster

+++++++++++++++++++++++++++++++++++++++++

prod_array_noself: Product of an array except itself

In this question, we used(or tried) the new syntax:
- insert(index, element) for inserting an element into the array. However, this has a bad runtime when index is always 0
we need to shift all the element right by one, which will result O(n) * O(n) = O(n**2) times
- for i in range(start, stop, step) loop. where start is the starting index, stop is the stopping index, and step is how much
step we should jump each time.
if we have (len(array) - 1, -1, -1), it means we want to start from the back of the array, and stop at index -1 which means 
loop through index 0 and stop, and for each loop, we have -1 step, which means we would like to count backwards by 1 each time

This question can be solved by brute force, but the runtime would be O(n**2) which is terrible
Can we use hashmap? Not that I can think of
Therefore, we used prefix and suffix products to solve this issue.
A prefix product is that we initialize an array such that(lets call it prefix_product): prefix_product[i] = the product of all
the elements prior to i.
A suffix product is that we initialize an array such that(lets call it suffix_product): suffix_product[i] = the product of all
the elemets after i.
Therefore, the problem is solvable by simply multiply the prefix and suffix product together:
- For i, we would like to know the product of the array except i 
- neither the prefix product of i and the suffix product of i contain i. 
- Therefore, by multiplying prefix_product[i - 1] * suffix_product[i + 1], we get the product of the array other than i

The runtime for this is O(n), and the space is also 3O(n). 
There is a better way to solve it in space O(1).

+++++++++++++++++++++++++++++++++++++++++

max_subarray:

The core idea is that, we keep a max_sum at all time, and update it whenever needed. This 'whenever needed' depends on:
- If the new element is positive:
    - If the current sum is < 0, we simply let that new element take the 'lead' and it becomes the max_sum. Since no other
    subarray came before it has a greater sum than it. Rememember to update the current sum to equal to this element
    - If the current sum is > 0, we add it to the current sum, and update the max sum
    - We update the max_sum by max(current_sum, max_sum)
- If the new element is negative:
we need to consider:
    - If the current sum + element > 0, which means that the current sum is positive and > element, we update the current_sum but
    do not update the max_sum, since adding a negative number must not increase the total sum
    - If the current sum + element < 0, this means that either:
        - Current_sum > 0 but < element, or
        - Current_sum < 0, meaning that all number we have encountered so far are negative
        In both cases, we need to set our current sum to 0 because in case of current_sum > 0, we would like to skip that element,
        which means that we are exploring a new subarray, and so that the current sum must be 0
        In case of current_sum < 0, which means all previous subarrays are negative, finding max_sum simply becomes finding the 
        negative value with the smallest absolute value. Therefore, we update max_sum with max(num, max_sum)

+++++++++++++++++++++++++++++++++++++++++

prod_subarray

FUCK THIS question
We need to find the subarray such that its product is the largest, there WILL BE negative and 0 present!!

The crux of the issue is that we need to figure out how to handle that 0 and negative number cases, which
is PAIN IN THE FUCKING ASS

Here are some examples for later use: [2,-5,-2,-4,3], [-9, 0, -10]
and to solve this issue, we need to consider the following cases:
- All number a positive, which is easy, just multiply them all up
- If contains negative number(s):
    - If the current product is positive, encounter a negative number immediately turn that to negative
    and likely to be small
    - If the current product is negative, encounter a negative number immediately turn that to positive
    and likely to be large
    - The degree of "Big or Small" depends on how "big or small" the current product is, therefore, we need
    a way to track that "current product"
- To do that, we keep track of the current_max and current_min for the current largest and smallest product,
  but note that they NOT the largest nor smallest product in the entire array!!

In the code, we derive them from max(tmp_max, tmp_min, num) and min(tmp_max, tmp_min, num), let me explain:
- current_max can be the new current_min if multiplied by a negative number!
- current_min can be the new current_max if multiplied by a negative number!
- current num can also be the new current max or new current min!

Exmaple: [2, -5, -2, -4, 3]
1>>>: tmp_max = current_max * 2 = 1 * 2 = 2, tmp_min = current_min * 2 = 1 * 2 = 2
    current_max = max(num, tmp_max, tmp_min) = max(2, 2, 2) = 2
    current_min = min(num, tmp_max, tmp_min) = min(2, 2, 2) = 2
    max_prod = max(max_prod, current_max) = max(2, 2) = 2
2>>>: tmp_max = current_max * -5 = 2 * -5 = -10, tmp_min = current_min * -5 = 2 * -5 = -10
    current_max = max(num, tmp_max, tmp_min) = max(-5, -10, -10) = -5
    current_min = min(num, tmp_max, tmp_min) = min(-5, -10, -10) = -10
    max_prod = max(max_prod, current_max) = max(2, -5) = 2
3>>>: tmp_max = current_max * -2 = -5 * -2 = 10, tmp_min = current_min * -2 = -10 * -2 = 20
    current_max = max(num, tmp_max, tmp_min) = max(-2, 10, 20) = 20
    current_min = min(num, tmp_max, tmp_min) = min(-2, 10, 20) = -2
    max_prod = max(max_prod, current_max) = max(2, 20) = 20
4>>>: tmp_max = current_max * -4 = 20 * -4 = -80, tmp_min = current_min * -4 = -2 * -4 = 8
    current_max = max(num, tmp_max, tmp_min) = max(-4, -80, 20) = 20
    current_min = min(num, tmp_max, tmp_min) = min(-4, -80, 8) = -80
    max_prod = max(max_prod, current_max) = max(2, 20) = 20
5>>>: tmp_max = current_max * 3 = -80 * 3 = -240, tmp_min = current_min * 3 = 8 * 3 = 24
    current_max = max(num, tmp_max, tmp_min) = max(3, -240, 24) = 24
    current_min = min(num, tmp_max, tmp_min) = min(3, -240, 24) = -240
    max_prod = max(max_prod, current_max) = max(20, 24) = 24

- If there is 0, we simply reinitalize current_max and min to 1 to prevent the multiplication from broken.
(since 0 bascially cut the array into two parts)

+++++++++++++++++++++++++++++++++++++++++

min_array: 
find the minimun element in a sorted and rotated array
Use a method similar to binary search.
In binary search, we have L and R pointer, middle pointer, we update them based on conditions


+++++++++++++++++++++++++++++++++++++++++

find_rotated_array:
find the target value in a sorted and rotated array in O(log(n)) time
Very very similar to min_array, which is find the minimum element in the array, but with a catch

Intuitively, we shoul use binary search to solve this issue, which means that we need:
- Left pointer
- Right pointer
- Middle pointer
and we update them depends on the scenario

So what are these scenarios?

Remember that the array is sorted and rotated, so it means that we have at least half of the array follows
a single pattern: Either increasing or decreasing

1. If the nums[mid] >= nums[l], it means that everything on the LHS will be smaller than the nums[mid]
2. If the nums[mid] < nums[l], it means that everything on the RHS will be larger than the nums[mid]

For 1, 
- if the target is larger than nums[mid], great, we ONLY need to search in the RHS, since everything on the
LHS will be smaller than the nums[mid]. Update l = mid + 1
- if the target is smaller than nums[mid], we need to choose which side to look for the target:
    a. Everything on the LHS is smaller than the mid, but it doesn't mean target is greater than all, since target < mid
    therefore, we compare the target with nums[l]: If it's bigger than it, but smaller than mid, then we ONLY search LHS. r = mid - 1
    b. Otherwise, on the RHS, we might still have some values < mid, and since target < nums[l], we search RHS! l = mid + 1

For 2, nums[mid] < nums[l]
- If the target is < nums[mid], we ONLY need to search the LHS since everything on the RHS will be > nums[mid] and
certainly larger than the target. Update r = mid - 1
- If the target is > nums[mid]:
    a. if target < nums[l], meaning that we search on the RHS
    b. if target > nums[l], we search on LHS, because there might be some values on LHS > nums[mid]



+++++++++++++++++++++++++++++++++++++++++
three_sum problem

Our own approach ultilized the two-sum algorithm, it is correct but exceeded time

The approach we learned is that:
- First we sort the array, so we know the order and can skip any duplicate(as requested by the question, no duplicate)
- We then for each element, initialze two pointers l and r, where l = i + 1 and r = len(nums) - 1
- The idea is that we keep summing the three numbers n, nums[l], nums[r], if the sum < 0, and since the array
is sorted, we increase the l. (remember to skip any duplicate) If > 0, then we decrese the r.
- If the sum is 0, then append these three elements to the result and keep increasing l.
- And remember, we do that for every element, left to right

+++++++++++++++++++++++++++++++++++++++++

most watery containter:

Intuition: We use two pointers with greedy algorithm to solve this issue:
- Only move the pointer that points to a smaller bar 
- Calculate the area for each step
- Each step, we ask: Is the new area bigger than the max area we've seen? If so, update the max area. If not, then forget about it and move on

Why we should move the pointer that points to smaller bar?
Because the area of the bucket depends on the lower bar(bucket effect, where shortest stave decide the max water volume can be held), therefore:
- If we move the taller pointer: The total area is guarentee to decrease -> even if the next stave is taller, the other lower stave is still there,
the area must decrese since the width decrease. 
- If we move the smaller pointer: We might move to a taller stave which outweight the decrease in width(which is always -1 per step), and therefore
we might have an area increase
- Update the max_area we have encountered each step (greedy)
-Until two pointers meet, we repeat the process

A greedy algorithm only focus on the local optimun solution without tracking and going back, meanwhile, it does not destroy the optimun solution globally

+++++++++++++++++++++++++++++++++++++++++

bit_sum.java

add two numbers together without using + or -

Use bitwise algorithm to solve this problem

a ^ b returns the sum without carries
a & b returns the carries of the sum
<< # shifts the bit by #

we keep doing this until b = 0

Important concept to know:
- Ones complement: Flip all the bits
- Twos complement: Flip all the bits and plus 1

+++++++++++++++++++++++++++++++++++++++++

hammingWeight

Find the number of '1' bit of the int

1. Use & 1 operator, we get the LSB (either 1 or 0)
2. Right shift the number by 1 every iteration and repeat step 1
3. Accumulate the number of 1s and return it


+++++++++++++++++++++++++++++++++++++++++
counting bits

Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), 
ans[i] is the number of 1's in the binary representation of i.

use hammingWeight as a helper function to do it for each i to n

+++++++++++++++++++++++++++++++++++++++++

Reverse linkedlist:

we need two intermediate variable: previous pointer, and the next pointer to store the
respecting values of the current node (because we are changing them later)

+++++++++++++++++++++++++++++++++++++++++

missing num

// we can sort the array and go through it one by one, in O(log(n)) time
// however, we iterate through the entire array, and while we do that, we:
// - Add up i to a variable a, and add up nums[i] to another variable b.
// - once we hit the last iteration, we simply substract b from a to get the result


However, a more novel approach to this question is using bitwise manipulation!

Recall that XOR operator only returns true in a ^ b if and only if either a or b is true but not both
XOR is also associative/commutative, which means that the order doesn't matter!

Therefore, since we know the number ranges from 0 to n, where n is the length of the array, we can XOR 
all the numbers together and whats left is the num that is missing.
- This is because we are guaranteed to get 0 if two same numbers XOR with each other, since they have the same bits
- Therefore, whats left must be the missing number that no other number can xor with it 


+++++++++++++++++++++++++++++++++++++++++
reverse bit

>> is bit left shift, it will pad left with the original MSB (0s if 0, 1s if 1)
>>> is logical left bit shift, it will pad left with 0s
<< is bit right shift, it always pad right with 0s


+++++++++++++++++++++++++++++++++++++++++

find cycle

use two pointers, a fast and slow pointers
the fast pointer will travel twice as fast as the slow pointer.
Therefore, if there is a cycle, the fast pointer will catch up with the slow pointer very soon


+++++++++++++++++++++++++++++++++++++++++

merge linked list

be mindful for the pointers
need a new head pointer that points to the result linked list for return


+++++++++++++++++++++++++++++++++++++++++

remove nth node from a linked list:

Use two pointer, fast pointer is excatly n steps ahead of the slow pointer

Important: Use a dummy pointer before the head, so we dont have to deal with the edge case anymore


+++++++++++++++++++++++++++++++++++++++++
Reorder lined list:


-We first reverse the second half (the .next for the last node of the reversed second half list should be null)
-Change the .next pointer in the last node of the first half list to null (important!)
- perform insertion

to get the first and second half list, we use a slow and fast pointers, where the fast pointer traverses twice as fast.
+++++++++++++++++++++++++++++++++++++++++


valid anagram

we learned Hasdmap in java:
HashMap<Character, Integer> dictionary = new HashMap<>();//where change the type of key and values
as needed.

HashMap.get(key) // read the value
HashMap.put(key, valueToBePut) // update value, if none, add new
HashMap.containsKey(key) //check if the key exists

We also learn string:
string is immutable, meaning that:
string a = "Hello"
a is a refernece to "Hello" where the actual string sits in string pool

string b = "Hello"

a == b will be true since they are references to the same string in the string pool (yes, java will
check if the string exists in the string pool first)

however, to compare the content of a and b, we should use:
a.equals(b)

we can also access the nth char of a string by:
string a = "Hello";
char b = a.charAt(n)

+++++++++++++++++++++++++++++++++++++++++

group anagram

we first convert all the string to char array
sort the array to make it a key
put this into the hashmap (check if the key already exists first)
iterate through the hashmap, then append all the elements into the list!

+++++++++++++++++++++++++++++++++++++++++

valid parenthesis

we learned how to use stack in java to solve this issue
specifically, we use Deque!!

just like list, we cant instantiate list since its just an interface, we have to use ArrayList
For Deque, its ArrayDeque:
Deque<Character> stack = new ArrayDeque<>();

for comparisom:

Character is a wrapper class of char, same applies to int/Integer
Character is a reference to the object, therefore, when comparing two Character, we should use .equals()
auto boxing and unboxing for char and Character comparison be done, so just use ==

+++++++++++++++++++++++++++++++++++++++++

valid palindrome:
determine if a string is symmetrical

remember! String is immutatble!
String is immutatble!
String is immutatble!
String is immutatble!
String is immutatble!
String is immutatble!

String is immutatble!
String is immutatble!String is immutatble!

we learned s.replaceAll("[^a-z]","") meaning replace everything with "" that are NOT a-z. ^ means NOT in regex

And yes just use two pointers to solve this issue.

+++++++++++++++++++++++++++++++++++++++++

max substring

use sliding windows techique: There is no need to repeat works that we have already done.

we need to have two pointers: Left and right. and adjust them as needed:

This question is a good demo, please see the inline comment!

+++++++++++++++++++++++++++++++++++++++++

max palindrome:
The runtime is O(n**2), but there is a better solution that is running at O(n) but not recommended
Use two pointers left and right, but they start expanding from the center, rather than from the start

WE need to consider all the possible centers of the palindrome:
Odd center: All the char in the string can be the odd centers
Even center: Between two chars, there is a center.
In total, we have n + (n - 1) = 2n - 1 centers

For odd: two pointers start from left = right
For even: right = left + 1

Main idea: We have a master loop such that i = 0, i++ until i = s.length()

for each i, we have two while loops, one for odd center and the other for even center.
Each while loop will expand on its own and terminates once the charAt(left) and right's differs
Record the localLongest word for each while loop and compare which one is longer and use that one
to compare it with the maxLongest. Repeat the same steps for the next i

Until the master loop terminates, we will have the maxLongest ready for return.

+++++++++++++++++++++++++++++++++++++++++

palindrom subarray

return the total number of palindrom subarray in the string

similiar to max palindrome! but just keep track of the total number and thats it

+++++++++++++++++++++++++++++++++++++++++

longestRepeatingReplacement

core idea is the window size and when to change the window size.
keep track of the most frequent char we have seen is the crux of this issue
please see the inline comment

+++++++++++++++++++++++++++++++++++++++++

max tree depth

recursively call the function itself! (Good old memory)

it might be scary tho but now we need to use it
and nothing to be afraid of :)

+++++++++++++++++++++++++++++++++++++++++

is same tree:

recursively call the function itself!

two trees are the same iff both reach their leaves without any false return

+++++++++++++++++++++++++++++++++++++++++

reverse tree

be careful for the order we do left and right compute then swap

+++++++++++++++++++++++++++++++++++++++++

subtree of antoher tree:

note that the structure of the subtree has to be the same too!
meaning that even though the subtree in the main tree matches all the values and poistions,
if the subtree in the main tree keeps growing, while we already checked all the nodes in the
target subtree, it still fails!

Please see the inline comment for ideaas
+++++++++++++++++++++++++++++++++++++++++


binaryOrderTraversal

We need to print out [[3],[9,20],[15,7]] where each inner list contains the node value for that level

- We learned queue (FIFO) : Queue<TreeNode> theTree = new LinkedList<>(); Queue is an interface, it 
can not be instantiated.
- Queue operations:
    a. theTree.offer(a) : Add a to the back. .add() also works but may throw error
    b. .peek() : peek the head value (the oldest value)
    c. .poll() : get the oldest value and remove it from the queue
- Reviewed List<>:
    a. List is an interface, we need to instantiate another lower class to List: ArrayList, LinkedList etc..
    b. We need to always initialize the List before use it. List<Integer> a = new ArrayList<>();
    c. .add() to attach an element to the list
    d. .get(n) to get the elemenet of the list at index n; (starting from 0)
    e. iterate through the list: for (Integer num : a)


+++++++++++++++++++++++++++++++++++++++++

recover the tree from its preorder and inorder inorder traversal 

please see the inline explainantion !!

make sure you now know what preorder, inorder, postorder, level traversal are!
If you dont, go google them or ask GPT NOW!

+++++++++++++++++++++++++++++++++++++++++

valid bst??

ya just create an arraylist and determine if its strictly increasing wtf
+++++++++++++++++++++++++++++++++++++++++

valid bst clean

a better way to solve the valid bst problem.

please see the inline explaination for reference

+++++++++++++++++++++++++++++++++++++++++

kth smallest in bst

basical idea: using inorder traversal (a type of depth first search) to create a sorted array.
once we hit size of k, we stop

then we simply return the k - 1 th element in the list


There is a better solution where no list is required. It uses a counter to keep track of the number
of execution, once hit k, terminate all execution and return the answer. Both counter and answers are 
variables inside the Solution class.

+++++++++++++++++++++++++++++++++++++++++

lowest common ancesstor l:

just know that 

p.val < l.val < q.val
therefore, we keep iterating until this condition is hit

please see inline explaination

+++++++++++++++++++++++++++++++++++++++++

trie

important concept to grasp, please read the inline comment!

+++++++++++++++++++++++++++++++++++++++++

search word with dot:

Used trie. Please see the inline comment for explaination.

But here are what we have learned:
- How to check if a char is a-z? if (c >= a and c <= z)
- We only recurse on the child that are not null, since if they are null, its guarentee a not found
hence the runtime isn't that bad.

- Be very careful for the order of the if statements, we should make sure the base case come first.
and only do calculations after we are sure the variables are not out of range.

+++++++++++++++++++++++++++++++++++++++++

matrix

define the matrix in java and some of its operations

+++++++++++++++++++++++++++++++++++++++++

modify matrix

instead of traversing row by row, we do col by col so we can get the 
correct max value;

+++++++++++++++++++++++++++++++++++++++++

Set matrix zero (and clean method)

Given an m x n integer matrix matrix, if an element is 0, 
set its entire row and column to 0's.

You must do it in place.

There are two versions of it: one is standard and the other one is
the preferred solution.

Please see the inline comments!!

+++++++++++++++++++++++++++++++++++++++++

spiral matrix

print them row/col by row/col.

Be careful for the boundary issue, please see the inline explaination

+++++++++++++++++++++++++++++++++++++++++

rotate image:

Linear algebra time, I am considering revisit some of its contents...

Please see the inline comment!
Pay close attention to the transpose and reverse part! We don't want to undo/redo the work!
+++++++++++++++++++++++++++++++++++++++++

